{
  "fileName": "cluster_top_tweets_intersection_with_fav_based_index.sql",
  "filePath": "src/scala/com/twitter/simclusters_v2/scio/bq_generation/sql/cluster_top_tweets_intersection_with_fav_based_index.sql",
  "url": "https://github.com/misbahsy/the-algorithm/src/scala/com/twitter/simclusters_v2/scio/bq_generation/sql/cluster_top_tweets_intersection_with_fav_based_index.sql",
  "summary": "This code is a SQL query that retrieves the top K tweets for each cluster in a Twitter dataset. The dataset is likely a collection of tweets that have been clustered based on some similarity metric. The purpose of this code is to identify the top K tweets for each cluster, where K is a specified number. \n\nThe code first creates a temporary table called `cluster_top_tweets` using a subquery that retrieves the top K tweets for each cluster. It then creates another temporary table called `flatten_cluster_top_tweets` by flattening the `topKTweetsForClusterKey` array in the `cluster_top_tweets` table. \n\nThe next section of the code retrieves the latest partition available in a separate dataset that is based on favorites. It creates a temporary table called `latest_fav_cluster_to_tweet` that stores the latest timestamp available in the favorites dataset. \n\nThe code then creates another temporary table called `flatten_fav_cluster_top_tweets` by flattening the `topTweetsByFavClusterNormalizedScore` array in the favorites dataset. It filters the results to only include tweets that were posted within the time range specified by the `START_TIME` and `END_TIME` parameters and that match the latest timestamp available in the favorites dataset. \n\nThe code then creates a temporary table called `flatten_cluster_top_tweets_intersection` by joining the `flatten_cluster_top_tweets` and `flatten_fav_cluster_top_tweets` tables on the `clusterId` and `tweetId` columns. This table contains the intersection of the top K tweets for each cluster and the top tweets in the favorites dataset. \n\nFinally, the code creates a temporary table called `processed_cluster_top_tweets` by aggregating the `flatten_cluster_top_tweets_intersection` table by `clusterId` and selecting the top K tweets for each cluster based on the `tweetScore` column. The result of the query is a table that contains the top K tweets for each cluster in the dataset. \n\nThis code is likely used as part of a larger project that involves analyzing Twitter data. The output of this query could be used to identify popular tweets within each cluster, which could be useful for understanding the topics and trends that are being discussed within each cluster. The output could also be used to identify influential users within each cluster based on the popularity of their tweets. \n\nExample usage:\n\n```\n-- Set parameters\nDECLARE START_TIME STRING DEFAULT \"2021-01-01 00:00:00\";\nDECLARE END_TIME STRING DEFAULT \"2021-01-31 23:59:59\";\nDECLARE CLUSTER_TOP_K_TWEETS INT64 DEFAULT 10;\n\n-- Run query\nWITH\n  cluster_top_tweets AS (\n    {CLUSTER_TOP_TWEETS_SQL}\n  ),\n\n  flatten_cluster_top_tweets AS (\n    SELECT\n      clusterId,\n      tweet.tweetId,\n      tweet.tweetScore,\n    FROM cluster_top_tweets, UNNEST(topKTweetsForClusterKey) AS tweet\n  ),\n\n  latest_fav_cluster_to_tweet AS (\n    SELECT\n      MAX(dateHour) AS latestTimestamp\n    FROM\n      `twttr-bq-cassowary-prod.user.simclusters_fav_based_cluster_to_tweet_index`\n    WHERE\n      TIMESTAMP(dateHour) >= TIMESTAMP(START_TIME)\n      AND TIMESTAMP(dateHour) <= TIMESTAMP(END_TIME)\n  ),\n\n  flatten_fav_cluster_top_tweets AS (\n    SELECT\n      clusterId.clusterId AS clusterId,\n      tweet.key AS tweetId\n    FROM\n      `twttr-bq-cassowary-prod.user.simclusters_fav_based_cluster_to_tweet_index`,\n      UNNEST(topKTweetsWithScores.topTweetsByFavClusterNormalizedScore) AS tweet,\n      latest_fav_cluster_to_tweet\n    WHERE\n      dateHour=latest_fav_cluster_to_tweet.latestTimestamp\n  ),\n\n  flatten_cluster_top_tweets_intersection AS (\n    SELECT\n      clusterId,\n      flatten_cluster_top_tweets.tweetId,\n      flatten_cluster_top_tweets.tweetScore\n    FROM\n      flatten_cluster_top_tweets\n    INNER JOIN\n      flatten_fav_cluster_top_tweets\n    USING(clusterId, tweetId)\n  ),\n\n  processed_cluster_top_tweets AS (\n    SELECT\n      clusterId,\n      ARRAY_AGG(STRUCT(tweetId, tweetScore) ORDER BY tweetScore LIMIT CLUSTER_TOP_K_TWEETS) AS topKTweetsForClusterKey\n    FROM flatten_cluster_top_tweets_intersection\n    GROUP BY clusterId\n  )\n\n SELECT *\n FROM processed_cluster_top_tweets\n```",
  "questions": "1. What is the purpose of the `cluster_top_tweets` CTE?\n    - The `cluster_top_tweets` CTE is used to retrieve the top tweets for each cluster.\n\n2. What is the significance of the `latest_fav_cluster_to_tweet` CTE?\n    - The `latest_fav_cluster_to_tweet` CTE retrieves the dateHour of the latest partition available for the fav-based dataset.\n\n3. What is the purpose of the `processed_cluster_top_tweets` CTE?\n    - The `processed_cluster_top_tweets` CTE is used to process the intersection of the top tweets for each cluster and the top tweets for each cluster based on favorites, and returns the top k tweets for each cluster."
}